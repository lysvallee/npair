from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException
from sqlmodel import Session, select
import httpx
import os
import shutil
from glob import glob
from models import Image, ModelMetrics
from services import get_db
from typing import List
import json
import logging

# Create logs directory if it doesn't exist
os.makedirs("/app/logs", exist_ok=True)

# Setup logging
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    filename="/app/logs/tracking_api.log",
)
logger = logging.getLogger(__name__)


app = FastAPI()

MODEL_API_URL = "http://model_api_track:8001/generate"
OBJECTS_DIR = "/data/storage/objects"
RENDERS_DIR = "/data/storage/renders"


def log_model_metrics(db: Session, **kwargs):
    new_metric = ModelMetrics(**kwargs)
    db.add(new_metric)
    db.commit()
    return new_metric


async def run_experiment(image_name: str, chunk_size: int, mc_resolution: int):
    async with httpx.AsyncClient(timeout=3600) as client:
        try:
            response = await client.post(
                MODEL_API_URL,
                json={
                    "image_name": image_name,
                    "chunk_size": chunk_size,
                    "mc_resolution": mc_resolution,
                },
            )
            response.raise_for_status()  # Raises HTTPError for bad responses
            return response.json()
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error occurred: {e}")
        except httpx.RequestError as e:
            logger.error(f"Request error occurred: {e}")
        except Exception as e:
            logger.error(f"Unexpected error occurred: {e}")
        return None


@app.post("/run_experiments")
async def run_experiments(db: Session = Depends(get_db)):
    categories = ["bicycle", "car", "plane"]
    chunk_sizes = [8192, 10240, 12288]
    mc_resolutions = [64, 128, 256]

    try:
        for category in categories:
            images = db.exec(
                select(Image).where(Image.image_category == category).limit(3)
            ).all()
            for image in images:
                logger.info(f"image: {image}")
                for chunk_size in chunk_sizes:
                    logger.info(f"chunk_size: {chunk_size}")
                    for mc_resolution in mc_resolutions:
                        logger.info(f"mc_resolution: {mc_resolution}")
                        result = await run_experiment(
                            image.image_name, chunk_size, mc_resolution
                        )
                        if not result:
                            logger.error(
                                f"Failed to generate model for {image.image_name}"
                            )
                            raise HTTPException(
                                status_code=500,
                                detail=f"Failed to generate model for {image.image_name}",
                            )
                        else:
                            object_name = f"{os.path.basename(os.path.splitext(image.image_name)[0])}_{chunk_size}_{mc_resolution}"
                            log_model_metrics(
                                db=db,
                                object_name=object_name,
                                **result["metrics"],
                                chunk_size=chunk_size,
                                mc_resolution=mc_resolution,
                            )

                            # Check if the 3D object was created
                            generated_object = os.path.join(OBJECTS_DIR, "mesh.glb")
                            if not os.path.exists(generated_object):
                                raise HTTPException(
                                    status_code=500,
                                    detail="Model generation did not produce expected output files",
                                )
                            # Define the output gif path
                            render_gif = os.path.join(OBJECTS_DIR, "render.gif")
                            # Generate unique names for the output files
                            object_3d_name = f"{object_name}.glb"
                            object_2d_name = f"{object_name}.gif"
                            object_3d_path = os.path.join(OBJECTS_DIR, object_3d_name)
                            object_2d_path = os.path.join(RENDERS_DIR, object_2d_name)
                            logger.debug(
                                f"Paths generated by the model: {object_3d_path, object_2d_path}"
                            )
                            # Move the results to the appropriate folders and delete intermediate images
                            shutil.move(generated_object, object_3d_path)
                            shutil.move(render_gif, object_2d_path)
                            png_files = glob(os.path.join(OBJECTS_DIR, "*.png"))
                            for png_file in png_files:
                                os.remove(png_file)

                            logger.info(
                                f"Experiment completed: {image.image_name}, chunk_size={chunk_size}, mc_resolution={mc_resolution}"
                            )
        return {"status": "success", "message": "Experiments completed"}
    except Exception as e:
        logger.error(f"An error occurred: {e}")
        raise HTTPException(status_code=500, detail=str(e))
